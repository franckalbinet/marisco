# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/handlers/data_format_transformation.ipynb.

# %% auto 0
__all__ = ['fname_in', 'fname_out', 'ValidateEnumsCB', 'ValidateNetCDFVarsCB', 'ConvertToHumanReadableCB']

# %% ../../nbs/handlers/data_format_transformation.ipynb 5
from pathlib import Path
from netCDF4 import Dataset
import pandas as pd
from fastcore.basics import patch, store_attr
import fastcore.all as fc

from marisco.configs import (
    NC_VARS,
    NC_GROUPS,
    Enums,
    lut_path
)

from marisco.callbacks import (
    Callback,
    Transformer,
    DecodeTimeCB
)  
    

# %% ../../nbs/handlers/data_format_transformation.ipynb 7
fname_in =  Path('../../_data/output/100-HELCOM-MORS-2024.nc')
fname_out = fname_in.with_suffix('.csv')

# %% ../../nbs/handlers/data_format_transformation.ipynb 15
class ValidateEnumsCB(Callback):
    "Validate enumeration mappings between NetCDF file and MARIS lookup tables."
    def __init__(self, 
                src_fname: str,  # Path to NetCDF file
                enums: Enums,    # MARIS lookup table enums
                verbose: bool = False
                ):
        fc.store_attr()
        
    def __call__(self, tfm: Transformer):
        """Process each group in the NetCDF file and validate its enums."""
        with Dataset(self.src_fname, 'r') as nc:
            for group_name in nc.groups:
                group = nc.groups[group_name]
                self._validate_group(group, group_name)
    
    def _validate_group(self, group, group_name: str):
        """Validate enum mappings for a specific group."""
        for var_name, var in group.variables.items():
            if not hasattr(var.datatype, 'enum_dict'): 
                continue
            
            nc_enum_dict = var.datatype.enum_dict
            if self.verbose:
                print(f"nc_enum_dict [{var_name}]:", nc_enum_dict)

            # Get original column name from NC_VARS mapping
            original_col = next((col for col, nc_var in NC_VARS.items() 
                               if nc_var == var_name), None)
            if not original_col: 
                continue

            # Compare enum mappings
            self._compare_mappings(
                nc_enum_dict,
                self.enums.types[original_col],
                group_name,
                var_name,
                original_col
            )
    
    def _compare_mappings(self, nc_dict: dict, lut_dict: dict, 
                         group_name: str, var_name: str, col_name: str):
        """Compare NetCDF enum dictionary with lookup table dictionary."""
        if self.verbose:
            print(f"lut_enum [{col_name}]:", lut_dict)
            
        # Check for mismatches between NetCDF and lookup table
        for key, value in nc_dict.items():
            if key not in lut_dict or lut_dict[key] != value:
                print(f"\nWarning: Enum mismatch in {group_name}/{var_name}")
                print(f"NetCDF value: {key} -> {value}")
                print(f"Lookup value: {key} -> {lut_dict.get(key, 'Not found')}")        

# %% ../../nbs/handlers/data_format_transformation.ipynb 19
class ValidateNetCDFVarsCB(Callback):
    " Validate that all variables in the NetCDF file are included in NC_VARS mapping. Identifies and reports any unmapped variables."
    def __init__(self, 
                src_fname: str,  # Path to NetCDF file
                verbose: bool = False
                ):
        fc.store_attr()
        
    def __call__(self, tfm: Transformer):
        """Check each group's variables against NC_VARS mapping."""
        unmapped_vars = {}
        
        with Dataset(self.src_fname, 'r') as nc:
            for group_name in nc.groups:
                group = nc.groups[group_name]
                group_vars = set(group.variables.keys())
                mapped_vars = {v for k, v in NC_VARS.items()}
                unmapped = group_vars - mapped_vars - {'id'}  # Exclude dimension variables
                
                if unmapped:
                    unmapped_vars[group_name] = unmapped
                    if self.verbose:
                        print(f"\nWarning: Unmapped variables in group {group_name}:")
                        print(f"Variables: {unmapped}")
        

# %% ../../nbs/handlers/data_format_transformation.ipynb 22
class ConvertToHumanReadableCB(Callback):
    """
    Convert enum values in DataFrames to their human-readable format.
    Uses the enum dictionary keys as the human-readable values.
    """
    def __init__(self, 
                src_fname: str,  # Path to NetCDF file
                verbose: bool = False
                ):
        fc.store_attr()
        
    def __call__(self, tfm: Transformer):
        """Convert numeric enum values to human-readable strings."""
        with Dataset(self.src_fname, 'r') as nc:
            for group_name, df in tfm.dfs.items():
                nc_group_name = NC_GROUPS[group_name]
                group = nc.groups[nc_group_name]
                
                # Process each variable that has an enum
                for var_name, var in group.variables.items():
                    if hasattr(var.datatype, 'enum_dict'):
                        # Get the original column name from NC_VARS mapping
                        original_col = next((col for col, nc_var in NC_VARS.items() 
                                          if nc_var == var_name), None)
                        
                        if original_col and original_col in df.columns:
                            enum_dict = {v: k for k, v in var.datatype.enum_dict.items()}
                            tfm.dfs[group_name][original_col] = df[original_col].map(enum_dict)
                            
                            if self.verbose:
                                print(f"Converted {original_col} to human readable format in {group_name}")

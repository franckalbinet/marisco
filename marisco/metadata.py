# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/metadata.ipynb.

# %% auto 0
__all__ = ['GLOB_ATTRS_TPL', 'GlobAttrsFeeder', 'BboxCB', 'DepthRangeCB', 'TimeRangeCB', 'ZoteroCB', 'KeyValuePairCB',
           'ZoteroItem']

# %% ../nbs/api/metadata.ipynb 2
import pandas as pd
from fastcore.xtras import load_pickle
import fastcore.all as fc

from .utils import (read_toml, get_bbox, 
                           Callback, run_cbs)
from .configs import BASE_PATH, get_cfgs

from cftime import num2date
from pyzotero import zotero
import json

# %% ../nbs/api/metadata.ipynb 3
GLOB_ATTRS_TPL = read_toml(BASE_PATH / 'cdl.toml')['global_attrs']

# %% ../nbs/api/metadata.ipynb 4
class GlobAttrsFeeder:
    def __init__(self, dfs, cbs=None, attrs=GLOB_ATTRS_TPL, logs=[]): fc.store_attr()
        
    def callback(self):
        run_cbs(self.cbs, self)
        
    def __call__(self):
        self.callback()
        return self.attrs

# %% ../nbs/api/metadata.ipynb 5
class BboxCB(Callback):
    "Compute dataset geographical bounding box"
    def __call__(self, obj):
        bbox = get_bbox(pd.concat(obj.dfs)) 
        lon_min, lon_max, lat_min, lat_max = [str(bound) for bound in bbox.bounds]
        obj.attrs.update({
            'geospatial_lat_min': lat_min, 
            'geospatial_lat_max': lat_max,
            'geospatial_lon_min': lon_min,
            'geospatial_lon_max': lon_max,
            'geospatial_bounds': bbox.wkt})

# %% ../nbs/api/metadata.ipynb 6
class DepthRangeCB(Callback):
    "Compute depth values range"
    def __call__(self, obj):
        max_depth = pd.concat(obj.dfs).depth.max()
        min_depth = pd.concat(obj.dfs).depth.min()
        obj.attrs.update({
            'geospatial_vertical_max': '0' if min_depth == 0 else str(-min_depth),
            'geospatial_vertical_min': str(-max_depth)})

# %% ../nbs/api/metadata.ipynb 7
class TimeRangeCB(Callback):
    "Compute time values range"
    def __call__(self, obj):
        time = pd.concat(obj.dfs)['time']
        start, end = [num2date(t, units=get_cfgs('units')['time']).isoformat() 
                      for t in (time.min(), time.max())]
        obj.attrs.update({
            'time_coverage_start': start,
            'time_coverage_end': end})

# %% ../nbs/api/metadata.ipynb 8
class ZoteroCB(Callback):
    "Retrieve Zotero metadata"
    def __init__(self, itemId): fc.store_attr()
        
    def __call__(self, obj):
        item = ZoteroItem(self.itemId, get_cfgs('zotero'))
        for attr in ['title', 'summary', 'creator_name']:
            obj.attrs[attr] = getattr(item, attr)()

# %% ../nbs/api/metadata.ipynb 9
class KeyValuePairCB(Callback):
    def __init__(self, k, v): fc.store_attr()
    def __call__(self, obj): obj.attrs[self.k] = self.v

# %% ../nbs/api/metadata.ipynb 10
class ZoteroItem:
    def __init__(self, item_id, cfgs):
        self.cfgs = cfgs
        self.item = self.getItem(item_id)
        
    def getItem(self, item_id):
        zot = zotero.Zotero(self.cfgs['lib_id'], 'group', self.cfgs['api_key'])
        return zot.item(item_id)
    
    def title(self):
        return self.item['data']['title']
    
    def summary(self):
        return self.item['data']['abstractNote']
    
    def creator_name(self):
        creators = [f'{c["creatorType"]}: {c["name"]}' for c in self.item['data']['creators']]
        return '; '.join(creators)
            
    def __repr__(self):
        return json.dumps(self.item, indent=4) 
